
as12, an absolute assembler for Motorola MCU's, version 1.2h

                        ;*******************************************************************************
                        ;                                 TAREA 5                                      *
                        ;                         PANTALLAS MULTIPLEXADAS                              *
                        ;*******************************************************************************
                        ;                                                                              *
                        ;       UNIVERSIDAD DE COSTA RICA                                              *
                        ;       FECHA 02/11/19                                                         *
                        ;       AUTOR: YEISON RODRIGUEZ PACHECO B56074                                 *
                        ;       COREREO: yeisonrodriguezpacheco@gmail.com                              *
                        ;                                                                              *
                        ;                                                                              *
                        ; Descripcion: Este programa se encarga de realizar todo el control en una fa- *
                        ; brica que hace bolsas de tornillos. El programa funciona en dos modos:
                        ; Modo config: En este modo se ingresan datos en el teclado de la tarjeta, el
                        ; teclado esta definido como vemos a continuacion:
                        ;                                                                              *
                        ;                 C0  C1  C2                                                   *
                        ;                 PA0 PA1 PA2                                                  *
                        ;                  |   |   |                                                   *
                        ;                -------------                                                 *
                        ;                |   |   |   |                                                 *
                        ;     PA4, R0 -  | 1 | 2 | 3 |                                                 *
                        ;                -------------                                                 *
                        ;                |   |   |   |                                                 *
                        ;     PA5, R1 -  | 4 | 5 | 6 |                                                 *
                        ;                -------------                                                 *
                        ;                |   |   |   |                                                 *
                        ;     PA6, R2 -  | 7 | 8 | 9 |                                                 *
                        ;                -------------                                                 *
                        ;                |   |   |   |                                                 *
                        ;     PA7, R3 -  | B | 0 | E |                                                 *
                        ;                -------------                                                 *
                        ;                                                                              *
                        ; Al ingresar el enter se guarda la cantidad de tornillos que tendra la bolsa, *
                        ; seguidamente si se baja el dipswitch numero 7 se pasara al modo run, que se  *
                        ; detalla a continuacion.                                                      *
                        ; Modo Run: El modo run es cuando se procede a contar los tornillos en la banda*
                        ; ,se muestra la cuenta de los tornillos en los display 3 y 4,y cuando se llena*
                        ; la bolsa se activa un rele que se encarga de dar el control al sistema que   *
                        ; empaca la bolsa. Para llenar otra bolsa se debe pulsar el sw5.               *
                        ;                                                                              *
                        ; Si hay dificultades para ver los display, se debe pulsar el sw2 para subir el*
                        ; brillo de los display, si por el contrario se desea bajar, presionar sw3.    *
                        ;                                                                              *
                        ; Para resetear el contador de bolsas, presionar sw4                           *
                        ;                                                                              *
                        ; Si se desea volver al modo config para cambiar el tamano de las bolsas, sim- *
                        ; plemente se debe subir el dipswitch 7 nuevamente y repetir el proceso.       *
                        ;                                                                              *
                        ; En el modo config siempre estara encendido el led PB1, en el modo run el PB0.*
                        ;                                                                              *
                        ; En la pantalla LED del dispositivo se mostrara informacion relevante sobre   *
                        ; las variables desplegadas en los display de 7 segmentes.                     *
                        ;                                                                              *
                        ;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
                        
                        
                        ;*******************************************************************************
                        ;                        DECLARACION ESTRUCTURAS DE DATOS
                        ;*******************************************************************************
00ff                    EOM:     EQU $FF
1000                            ORG $1000
1000 02                 MAX_TCL:        db $02      ;Cantidad de teclas que se van a leer  (longitud)
1001                    TECLA:          ds 1        ;Tecla leida en un momento t0
1002                    TECLA_IN:       ds 1        ;Tecla leida en un momento t1
1003                    CONT_REB:       ds 1        ;Contador de rebotes que espera 10ms por la subrutina RTI_ISR
1004                    CONT_TCL:       ds 1        ;Contador de teclas que han sido escritas, usada en FORMAR_ARRAY
1005                    PATRON:         ds 1        ;Contador que va hasta 5, usado por MUX_TECLADO
1006                    BANDERAS:       ds 1        ;COMANDO_DATO:ALERTA:X:MODSEL:CAMBIO_MODO:ARRAY_OK:TLC_LEIDA:TCL_LISTA
                                                    ; CAMBIO_MODO es para que la pantalla LCD solo se refresque una vez entre cada cambio de modo
                                                    ; MODSEL. 1 es para modo CPROG, 0 MODO RUN
                                                    ; COMANDO_DATO: Esta bandera es 0 si se envia un comando, 1 si se envian datos
1007                    CUENTA:         ds 1        ; Lleva la cuenta de los tornillos
1008                    ACUMUL:         ds 1        ; Contador de empaques procesados, llega a 99 y rebasa hasta 0 al sumarle mas
1009                    CPROG:          ds 1        ; Con cuanto se llena una bolsita de tornillos
100a fa                 VMAX:           db 250      ; Cuenta maxima a la que llega TIMER_CUENTA (subrutina run)
                        
100b                    TIMER_CUENTA:   ds 1        ; Variable utilizada para contar con RTI hasta VMAX (subrutina run)
100c                    LEDS:           ds 1        ; LEDS a ser encendidos
100d                    BRILLO:         ds 1        ; Brillo de los leds, se sube de 5 en 5. Va de 0 a 100 es la variable K
100e                    CONT_DIG:       ds 1        ; Va de 0 a 3 (solo se usan sus dos primero bits) y cuenta
                                                    ; El digito que se va a encenter
100f                    CONT_TICKS:     ds 1        ; Cuenta tiks del Output compare, va de 0 a 100
1010                    DT:             ds 1        ; DT = N - K duty cicle
1011                    LOW:            ds 1        ; Utilizada por la subrutina BIN_BCD
1012                    BCD1:           ds 1        ; Digitos en BCD, los guarda la subrutina BIN_BCD
1013                    BCD2:           ds 1
1014                    DISP1:          ds 1        ; Los 4 valores de los display que se escriben en PORTB
1015                    DISP2:          ds 1
1016                    DISP3:          ds 1
1017                    DISP4:          ds 1
1018                    CONT_7SEG:      ds 2        ; Para hacer que cada 10hz se llame a BCD_7SEG
101a                    CONT_DELAY:     ds 1
101b 64                 D2mS:           dB 100
101c 0d                 D260uS:         dB 13
101d 03                 D60uS:          dB 3
101e                    CLEAR_LCD:      ds 1
101f 80                 ADD_L1:         dB $80
1020 c0                 ADD_L2:         dB $C0
1021                    BIN1:           ds 1
1022                    BIN2:           ds 1
1023                    BCD1_aux:           ds 1        ; Digitos en BCD, los guarda la subrutina BIN_BCD
1024                    BCD2_aux:           ds 1
1025                    BCD_L:          ds 1
1026                    BCD_H:          ds 1
1027                    POT:            ds 1
1030                            ORG $1030
1030 ff ff ff ff ff ff  NUM_ARRAY:      db $ff,$ff,$ff,$ff,$ff,$ff             ;Guarda los numeros ingresados en el teclado
                        
1040                            ORG $1040
1040 01 02 03 04 05 06  TECLAS:         db $01,$02,$03,$04,$05,$06,$07,$08,$09,$0B,$0,$0E ;Tabla de teclas del teclado
     07 08 09 0b 00 0e
                        
1050                            ORG $1050
1050 3f 06 5b 4f 66 6d  SEGMENT:       dB $3f,$06,$5b,$4f,$66,$6d,$7d,$07,$7f,$6f,$40,$00
     7d 07 7f 6f 40 00
                        
1060                            ORG $1060
1060 04 28 28 06 0c     iniDsp:         db $04,$28,$28,$06,%00001100 ;disp on, cursor off, no blinkin
1065 ff                                 db EOM
                        
                        
                                
1070                              ORG $1070       ; mensajes
1070 4d 4f 44 4f 20 43  Msj_config_1:    fcc "MODO CONFIG"
     4f 4e 46 49 47
107b ff                         db EOM
107c 49 4e 47 52 45 53  Msj_config_2:    fcc "INGRESE CPROG:"
     45 20 43 50 52 4f
     47 3a
108a ff                         db EOM
108b 4d 4f 44 4f 20 52  Msj_run_1:    fcc "MODO RUN   "
     55 4e 20 20 20
1096 ff                         db EOM
1097 41 43 55 4d 55 4c  Msj_run_2:    fcc "ACUMUL.-CUENTA"
     2e 2d 43 55 45 4e
     54 41
10a5 ff                         db EOM
                        #include registers.inc
                        ; Memory maps and register equates
                        ; Choose one of DBUG12MAP (normal operation under DBUG12)
                        ;               EEPROMMAP  (DBUG12 in EEPROM mode)
                        ;               FLASHMAP   (Program loaded into Flash ROM)
0000                    DBUG12MAP equ 0        ; Memory mode is DBUG12MAP
                        ; EEPROMMAP equ 0         ; Memory mode is EEPROMMAP
                        #ifdef DBUG12MAP
0000                    REGBASE        equ        $0        ; register base
1000                    DATASTART equ        $1000        ; Start of data memory
2000                    DATAEND  equ        $2000        ; Stack pointer initial value (end of data RAM area)
2000                    PRSTART equ        $2000        ; Start of program memory (might be ROM)
3bff                    PREND        equ        $3BFF        ; End of program memory
                        
                        ; Functions in D-Bug12
ee84                    Getchar        equ        $EE84        ; Implemented in emulator
ee86                    Putchar equ        $EE86   ; Implemented in emulator
ee88                    Printf  equ     $EE88
ee8a                    GetCmdLine equ  $EE8A   ; FAR call
ee8e                    Sscanhex equ        $EE8E   ; FAR call
ee92                    Isxdigit equ    $EE92
ee94                    Toupper equ     $EE94
ee96                    Isalpha equ     $EE96
ee98                    Strlen  equ     $EE98
ee9a                    Strcpy  equ     $EE9A
ee9c                    Out2hex equ     $EE9C   ; FAR call
eea0                    Out4hex equ     $EEA0   ; FAR call
eea4                    SetUserVector equ $EEA4 ; No longer used
eea6                    WriteEEByte equ $EEA6   ; FAR call
eeaa                    EraseEE equ     $EEAA   ; FAR call
eeae                    ReadMem equ     $EEAE   ; FAR call
eeb2                    WriteMem equ    $EEB2   ; FAR call
                        
3e00                    VECTORTABLE equ $3E00        ; Vectors go here SHOULD ALSO INITIALIZE AT RUNTIME
0000                    STATICVECTORS equ 0        ; Define vectors statically (in "ROM")
0000                    INITIALIZEVECTORS equ 0        ; Initialize vectors at runtime
                        #endif
                        
                        #ifdef EEPROMMAP
                        REGBASE        equ        $0        ; register base MAY BE MOVED TO MAKE FULL EEPROM ACCESSABLE
                        DATASTART equ        $1000        ; Start of data memory
                        DATAEND  equ        $3E00        ; Stack pointer initial value (end of data RAM area)
                        PRSTART equ        $400        ; Start of program memory
                        PREND        equ        $FFF        ; End of program memory
                        
                        VECTORTABLE equ $3E00        ; Vectors go here -- MUST BE INITIALIZED AT RUNTIME
                        INITIALIZEVECTORS equ 0        ; Initialize vectors at runtime
                        #endif
                        
                        #ifdef FLASHMAP
                        REGBASE        equ        $0        ; register base MAY BE MOVED TO MAKE FULL EEPROM ACCESSABLE
                        DATASTART equ        $1000        ; Start of data memory
                        DATAEND  equ        $4000        ; Stack pointer initial value (end of data RAM area)
                        PRSTART equ        $8000        ; Start of program memory
                        ; Note -- there are problems using the current free assemblers with paged memory
                        ; Best bet is to use logical addresses $8000 up only, set page register to 3E,
                        ; Change S1 records for $8000-BFFF to S2 records for page 3E and S1 records for $C000-$EFFF to
                        ; page 3F. Program startup vector goes in EFFE, and needs to be iin page 3F so PPAGE can be changed.
                        PREND        equ        $EF7F        ; End of program memory
                        
                        VECTORTABLE equ $EF80        ; Vectors go here -- MUST BE INITIALIZED STATICALLY
                        STATICVECTORS equ 0        ; Define vectors statically (in "ROM")
                        #endif
                        
                        
1000                    RAMSTART equ        DATASTART ; For compatibility
2000                    RAMEND equ        DATAEND
                        
3e00                    UserRsrv0x80 equ (0*2)+VECTORTABLE
3e02                    UserRsrv0x82 equ (1*2)+VECTORTABLE
3e04                    UserRsrv0x84 equ (2*2)+VECTORTABLE
3e06                    UserRsrv0x86 equ (3*2)+VECTORTABLE
3e08                    UserRsrv0x88 equ (4*2)+VECTORTABLE
3e0a                    UserRsrv0x8a equ (5*2)+VECTORTABLE
3e0c                    UserPWMShDn equ (6*2)+VECTORTABLE
3e0e                    UserPortP equ (7*2)+VECTORTABLE
3e10                    UserMSCAN4Tx equ (8*2)+VECTORTABLE
3e12                    UserMSCAN4Rx equ (9*2)+VECTORTABLE
3e14                    UserMSCAN4Errs equ (10*2)+VECTORTABLE
3e16                    UserMSCAN4Wake equ (11*2)+VECTORTABLE
3e18                    UserMSCAN3Tx equ (12*2)+VECTORTABLE
3e1a                    UserMSCAN3Rx equ (13*2)+VECTORTABLE
3e1c                    UserMSCAN3Errs equ (14*2)+VECTORTABLE
3e1e                    UserMSCAN3Wake equ (15*2)+VECTORTABLE
3e20                    UserMSCAN2Tx equ (16*2)+VECTORTABLE
3e22                    UserMSCAN2Rx equ (17*2)+VECTORTABLE
3e24                    UserMSCAN2Errs equ (18*2)+VECTORTABLE
3e26                    UserMSCAN2Wake equ (19*2)+VECTORTABLE
3e28                    UserMSCAN1Tx equ (20*2)+VECTORTABLE
3e2a                    UserMSCAN1Rx equ (21*2)+VECTORTABLE
3e2c                    UserMSCAN1Errs equ (22*2)+VECTORTABLE
3e2e                    UserMSCAN1Wake equ (23*2)+VECTORTABLE
3e30                    UserMSCAN0Tx equ (24*2)+VECTORTABLE
3e32                    UserMSCAN0Rx equ (25*2)+VECTORTABLE
3e34                    UserMSCAN0Errs equ (26*2)+VECTORTABLE
3e36                    UserMSCAN0Wake equ (27*2)+VECTORTABLE
3e38                    UserFlash equ (28*2)+VECTORTABLE
3e3a                    UserEEPROM equ (29*2)+VECTORTABLE
3e3c                    UserSPI2 equ (30*2)+VECTORTABLE
3e3e                    UserSPI1 equ (31*2)+VECTORTABLE
3e40                    UserIIC equ (32*2)+VECTORTABLE
3e42                    UserDLC equ (33*2)+VECTORTABLE
3e44                    UserSCME equ (34*2)+VECTORTABLE
3e46                    UserCRG equ (35*2)+VECTORTABLE
3e48                    UserPAccBOv equ (36*2)+VECTORTABLE
3e4a                    UserModDwnCtr equ (37*2)+VECTORTABLE
3e4c                    UserPortH equ (38*2)+VECTORTABLE
3e4e                    UserPortJ equ (39*2)+VECTORTABLE
3e50                    UserAtoD1 equ (40*2)+VECTORTABLE
3e52                    UserAtoD0 equ (41*2)+VECTORTABLE
3e54                    UserSCI1 equ (42*2)+VECTORTABLE
3e56                    UserSCI0 equ (43*2)+VECTORTABLE
3e58                    UserSPI0 equ (44*2)+VECTORTABLE
3e5a                    UserPAccEdge equ (45*2)+VECTORTABLE
3e5c                    UserPAccOvf equ (46*2)+VECTORTABLE
3e5e                    UserTimerOvf equ (47*2)+VECTORTABLE
3e60                    UserTimerCh7 equ (48*2)+VECTORTABLE
3e62                    UserTimerCh6 equ (49*2)+VECTORTABLE
3e64                    UserTimerCh5 equ (50*2)+VECTORTABLE
3e66                    UserTimerCh4 equ (51*2)+VECTORTABLE
3e68                    UserTimerCh3 equ (52*2)+VECTORTABLE
3e6a                    UserTimerCh2 equ (53*2)+VECTORTABLE
3e6c                    UserTimerCh1 equ (54*2)+VECTORTABLE
3e6e                    UserTimerCh0 equ (55*2)+VECTORTABLE
3e70                    UserRTI equ (56*2)+VECTORTABLE
3e72                    UserIRQ equ (57*2)+VECTORTABLE
3e74                    UserXIRQ equ (58*2)+VECTORTABLE
3e76                    UserSWI equ (59*2)+VECTORTABLE
3e78                    UserTrap equ (60*2)+VECTORTABLE
                        
                        
                        *
                        *
                        *  HC12 i/o register locations (9s12dp256)
                        *
                        *
0000                    PORTA:          equ REGBASE+0   ;port a = address lines a8 - a15
0001                    PORTB:          equ REGBASE+1   ;port b = address lines a0 - a7
0002                    DDRA:           equ REGBASE+2   ;port a direction register
0003                    DDRB:           equ REGBASE+3   ;port b direction register
                        
0008                    PORTE:          equ REGBASE+8   ;port e = mode,irq and control signals
0009                    DDRE:           equ REGBASE+9   ;port e direction register
000a                    PEAR:           equ REGBASE+$a  ;port e assignments
000b                    MODE:           equ REGBASE+$b  ;mode register
000c                    PUCR:           equ REGBASE+$c  ;port pull-up control register
000d                    RDRIV:          equ REGBASE+$d  ;port reduced drive control register
000e                    EBICTL:                equ REGBASE+$e  ;e stretch control
                        
0010                    INITRM:         equ REGBASE+$10 ;ram location register
0011                    INITRG:         equ REGBASE+$11 ;register location register
0012                    INITEE:         equ REGBASE+$12 ;eeprom location register
0013                    MISC:           equ REGBASE+$13 ;miscellaneous mapping control
0014                    MTST0:          equ REGBASE+$14 ; reserved
0015                    ITCR:           equ REGBASE+$15 ;interrupt test control register
0016                    ITEST:          equ REGBASE+$16 ;interrupt test register
0017                    MTST1:          equ REGBASE+$17 ; reserved
                        
001a                    PARTIDH:        equ REGBASE+$1a ;part id high
001b                    PARTIDL:        equ REGBASE+$1b ;part id low
001c                    MEMSIZ0:        equ REGBASE+$1c ;memory size
001d                    MEMSIZ1:        equ REGBASE+$1d ;memory size
001e                    IRQCR:          equ REGBASE+$1e ;interrupt control register
001e                    INTCR:          equ REGBASE+$1e ;interrupt control register (old name)
001f                    HPRIO:          equ REGBASE+$1f ;high priority reg
                        
0028                    BKPCT0:         equ REGBASE+$28 ;break control register
0029                    BKPCT1:         equ REGBASE+$29 ;break control register
002a                    BKP0X:          equ REGBASE+$2a ; break 0 index register
002b                    BKP0H:          equ REGBASE+$2b ; break 0 pointer high
002c                    BRP0L:          equ REGBASE+$2c ; break 0 pointer low
002d                    BKP1X:          equ REGBASE+$2d ; break 1 index register
002e                    BKP1H:          equ REGBASE+$2e ; break 1 pointer high
002f                    BRP1L:          equ REGBASE+$2f ; break 1 pointer low
0030                    PPAGE:                equ REGBASE+$30 ;program page register
                        
0032                    PORTK:                equ REGBASE+$32 ;port k data
0033                    DDRK:                equ REGBASE+$33 ;port k direction
                        
0034                    SYNR:           equ REGBASE+$34 ; synthesizer / multiplier register
0035                    REFDV:          equ REGBASE+$35 ; reference divider register
0036                    CTFLG:          equ REGBASE+$36 ; reserved
0037                    CRGFLG:         equ REGBASE+$37 ; pll flags register
0038                    CRGINT:         equ REGBASE+$38 ; pll interrupt register
0039                    CLKSEL:         equ REGBASE+$39 ; clock select register
003a                    PLLCTL:         equ REGBASE+$3a ; pll control register
003b                    RTICTL:         equ REGBASE+$3b ;real time interrupt control
003c                    COPCTL:         equ REGBASE+$3c ;watchdog control
003d                    FORBYP:         equ REGBASE+$3d ;
003e                    CTCTL:          equ REGBASE+$3e ;
003f                    ARMCOP:         equ REGBASE+$3f ;cop reset register
                        
0040                    TIOS:           equ REGBASE+$40 ;timer input/output select
0041                    CFORC:          equ REGBASE+$41 ;timer compare force
0042                    OC7M:           equ REGBASE+$42 ;timer output compare 7 mask
0043                    OC7D:           equ REGBASE+$43 ;timer output compare 7 data
0044                    TCNT:           equ REGBASE+$44 ;timer counter register hi
                        *TCNT:          equ REGBASE+$45 ;timer counter register lo
0046                    TSCR:           equ REGBASE+$46 ;timer system control register (Old Name)
0046                    TSCR1:          equ REGBASE+$46 ;timer system control register
0047                    TTOV:           equ REGBASE+$47 ;reserved
0048                    TCTL1:          equ REGBASE+$48 ;timer control register 1
0049                    TCTL2:          equ REGBASE+$49 ;timer control register 2
004a                    TCTL3:          equ REGBASE+$4a ;timer control register 3
004b                    TCTL4:          equ REGBASE+$4b ;timer control register 4
004c                    TMSK1:          equ REGBASE+$4c ;timer interrupt mask 1 (Old Name)
004c                    TIE:            equ REGBASE+$4c ;timer interrupt mask 1
004d                    TMSK2:          equ REGBASE+$4d ;timer interrupt mask 2 (Old Name)
004d                    TSCR2:          equ REGBASE+$4d ;timer interrupt mask 2
004e                    TFLG1:          equ REGBASE+$4e ;timer flags 1
004f                    TFLG2:          equ REGBASE+$4f ;timer flags 2
0050                    TC0:            equ REGBASE+$50 ;timer capture/compare register 0
0052                    TC1:            equ REGBASE+$52 ;timer capture/compare register 1
0054                    TC2:            equ REGBASE+$54 ;timer capture/compare register 2
0056                    TC3:            equ REGBASE+$56 ;timer capture/compare register 3
0058                    TC4:            equ REGBASE+$58 ;timer capture/compare register 4
005a                    TC5:            equ REGBASE+$5a ;timer capture/compare register 5
005c                    TC6:            equ REGBASE+$5c ;timer capture/compare register 6
005e                    TC7:            equ REGBASE+$5e ;timer capture/compare register 7
0060                    PACTL:          equ REGBASE+$60 ;pulse accumulator controls
0061                    PAFLG:          equ REGBASE+$61 ;pulse accumulator flags
0062                    PACN3:          equ REGBASE+$62 ;pulse accumulator counter 3
0063                    PACN2:          equ REGBASE+$63 ;pulse accumulator counter 2
0064                    PACN1:          equ REGBASE+$64 ;pulse accumulator counter 1
0065                    PACN0:          equ REGBASE+$65 ;pulse accumulator counter 0
0066                    MCCTL:          equ REGBASE+$66 ;modulus down conunter control
0067                    MCFLG:          equ REGBASE+$67 ;down counter flags
0068                    ICPAR:          equ REGBASE+$68 ;input pulse accumulator control
0069                    DLYCT:          equ REGBASE+$69 ;delay count to down counter
006a                    ICOVW:          equ REGBASE+$6a ;input control overwrite register
006b                    ICSYS:          equ REGBASE+$6b ;input control system control
                        
006d                    TIMTST:         equ REGBASE+$6d ;timer test register
                        
0070                    PBCTL:          equ REGBASE+$70 ; pulse accumulator b control
0071                    PBFLG:          equ REGBASE+$71 ; pulse accumulator b flags
0072                    PA3H:           equ REGBASE+$72 ; pulse accumulator holding register 3
0073                    PA2H:           equ REGBASE+$73 ; pulse accumulator holding register 2
0074                    PA1H:           equ REGBASE+$74 ; pulse accumulator holding register 1
0075                    PA0H:           equ REGBASE+$75 ; pulse accumulator holding register 0
0076                    MCCNT:          equ REGBASE+$76 ; modulus down counter register
                        *MCCNTL:        equ REGBASE+$77 ; low byte
0078                    TCOH:           equ REGBASE+$78 ; capture 0 holding register
007a                    TC1H:           equ REGBASE+$7a ; capture 1 holding register
007c                    TC2H:           equ REGBASE+$7c ; capture 2 holding register
007e                    TC3H:           equ REGBASE+$7e ; capture 3 holding register
                        
0080                    ATD0CTL0:       equ REGBASE+$80 ;adc control 0 (reserved)
0081                    ATD0CTL1:       equ REGBASE+$81 ;adc control 1 (reserved)
0082                    ATD0CTL2:       equ REGBASE+$82 ;adc control 2
0083                    ATD0CTL3:       equ REGBASE+$83 ;adc control 3
0084                    ATD0CTL4:       equ REGBASE+$84 ;adc control 4
0085                    ATD0CTL5:       equ REGBASE+$85 ;adc control 5
0086                    ATD0STAT:       equ REGBASE+$86 ;adc status register hi
0086                    ATD0STAT0:      equ REGBASE+$86 ;adc status register hi
008b                    ATD0STAT1:      equ REGBASE+$8b ;adc status register lo
0088                    ATD0TEST:       equ REGBASE+$88 ;adc test (reserved)
                        *atd0test       equ REGBASE+$89 ;
                        
008d                    ATD0DIEN:        equ REGBASE+$8d ;
                        
008f                    PORTAD:         equ REGBASE+$8f ;port adc = input only
0090                    ADR00H:         equ REGBASE+$90 ;adc result 0 register
0092                    ADR01H:         equ REGBASE+$92 ;adc result 1 register
0094                    ADR02H:         equ REGBASE+$94 ;adc result 2 register
0096                    ADR03H:         equ REGBASE+$96 ;adc result 3 register
0098                    ADR04H:         equ REGBASE+$98 ;adc result 4 register
009a                    ADR05H:         equ REGBASE+$9a ;adc result 5 register
009c                    ADR06H:         equ REGBASE+$9c ;adc result 6 register
009e                    ADR07H:         equ REGBASE+$9e ;adc result 7 register
                        
00a0                    PWME:                equ REGBASE+$a0 ;pwm enable
00a1                    PWMPOL:         equ REGBASE+$a1 ;pwm polarity
00a2                    PWMCLK:         equ REGBASE+$a2 ;pwm clock select register
00a3                    PWMPRCLK:       equ REGBASE+$a3 ;pwm prescale clock select register
00a4                    PWMCAE:         equ REGBASE+$a4 ;pwm center align select register
00a5                    PWMCTL:         equ REGBASE+$a5 ;pwm control register
00a6                    PWMTST:         equ REGBASE+$a6 ;reserved
00a7                    PWMPRSC:        equ REGBASE+$a7 ;reserved
00a8                    PWMSCLA:        equ REGBASE+$a8 ;pwm scale a
00a9                    PWMSCLB:        equ REGBASE+$a9 ;pwm scale b
00aa                    PWMSCNTA:       equ REGBASE+$aa ;reserved
00ab                    PWMSCNTB:       equ REGBASE+$ab ;reserved
00ac                    PWMCNT0:        equ REGBASE+$ac ;pwm channel 0 counter
00ad                    PWMCNT1:        equ REGBASE+$ad ;pwm channel 1 counter
00ae                    PWMCNT2:        equ REGBASE+$ae ;pwm channel 2 counter
00af                    PWMCNT3:        equ REGBASE+$af ;pwm channel 3 counter
00b0                    PWMCNT4:        equ REGBASE+$b0 ;pwm channel 4 counter
00b1                    PWMCNT5:        equ REGBASE+$b1 ;pwm channel 5 counter
00b2                    PWMCNT6:        equ REGBASE+$b2 ;pwm channel 6 counter
00b3                    PWMCNT7:        equ REGBASE+$b3 ;pwm channel 7 counter
00b4                    PWMPER0:        equ REGBASE+$b4 ;pwm channel 0 period
00b5                    PWMPER1:        equ REGBASE+$b5 ;pwm channel 1 period
00b6                    PWMPER2:        equ REGBASE+$b6 ;pwm channel 2 period
00b7                    PWMPER3:        equ REGBASE+$b7 ;pwm channel 3 period
00b8                    PWMPER4:        equ REGBASE+$b8 ;pwm channel 4 period
00b9                    PWMPER5:        equ REGBASE+$b9 ;pwm channel 5 period
00ba                    PWMPER6:        equ REGBASE+$ba ;pwm channel 6 period
00bb                    PWMPER7:        equ REGBASE+$bb ;pwm channel 7 period
00bc                    PWMDTY0:        equ REGBASE+$bc ;pwm channel 0 duty cycle
00bd                    PWMDTY1:        equ REGBASE+$bd ;pwm channel 1 duty cycle
00be                    PWMDTY2:        equ REGBASE+$be ;pwm channel 2 duty cycle
00bf                    PWMDTY3:        equ REGBASE+$bf ;pwm channel 3 duty cycle
00c0                    PWMDTY4:        equ REGBASE+$c0 ;pwm channel 4 duty cycle
00c1                    PWMDTY5:        equ REGBASE+$c1 ;pwm channel 5 duty cycle
00c2                    PWMDTY6:        equ REGBASE+$c2 ;pwm channel 6 duty cycle
00c3                    PWMDTY7:        equ REGBASE+$c3 ;pwm channel 7 duty cycle
00c4                    PWMSDN:         equ REGBASE+$c4 ;pwm shutdown register
                        
00c8                    SC0BDH:         equ REGBASE+$c8 ;sci 0 baud reg hi byte
00c9                    SC0BDL:         equ REGBASE+$c9 ;sci 0 baud reg lo byte
00ca                    SC0CR1:         equ REGBASE+$ca ;sci 0 control1 reg
00cb                    SC0CR2:         equ REGBASE+$cb ;sci 0 control2 reg
00cc                    SC0SR1:         equ REGBASE+$cc ;sci 0 status reg 1
00cd                    SC0SR2:         equ REGBASE+$cd ;sci 0 status reg 2
00ce                    SC0DRH:         equ REGBASE+$ce ;sci 0 data reg hi
00cf                    SC0DRL:         equ REGBASE+$cf ;sci 0 data reg lo
                        
00d0                    SC1BDH:         equ REGBASE+$d0 ;sci 1 baud reg hi byte
00d1                    SC1BDL:         equ REGBASE+$d1 ;sci 1 baud reg lo byte
00d2                    SC1CR1:         equ REGBASE+$d2 ;sci 1 control1 reg
00d3                    SC1CR2:         equ REGBASE+$d3 ;sci 1 control2 reg
00d4                    SC1SR1:         equ REGBASE+$d4 ;sci 1 status reg 1
00d5                    SC1SR2:         equ REGBASE+$d5 ;sci 1 status reg 2
00d6                    SC1DRH:         equ REGBASE+$d6 ;sci 1 data reg hi
00d7                    SC1DRL:         equ REGBASE+$d7 ;sci 1 data reg lo
                        
00d8                    SPI0CR1:        equ REGBASE+$d8 ;spi 0 control1 reg
00d9                    SPI0CR2:        equ REGBASE+$d9 ;spi 0 control2 reg
00da                    SPI0BR:         equ REGBASE+$da ;spi 0 baud reg
00db                    SPI0SR:         equ REGBASE+$db ;spi 0 status reg hi
00dd                    SP0DR:          equ REGBASE+$dd ;spi 0 data reg  FOR COMPATIBILITY
00dd                    SPI0DR:          equ REGBASE+$dd ;spi 0 data reg
                        
00e0                    IBAD:                equ REGBASE+$e0 ;i2c bus address register
00e1                    IBFD:                equ REGBASE+$e1 ;i2c bus frequency divider
00e2                    IBCR:                equ REGBASE+$e2 ;i2c bus control register
00e3                    IBSR:                equ REGBASE+$e3 ;i2c bus status register
00e4                    IBDR:                equ REGBASE+$e4 ;i2c bus message data register
                        
00e8                    DLCBCR1:        equ REGBASE+$e8 ;bdlc control regsiter 1
00e9                    DLCBSVR:        equ REGBASE+$e9 ;bdlc state vector register
00ea                    DLCBCR2:        equ REGBASE+$ea ;bdlc control register 2
00eb                    DLCBDR:                equ REGBASE+$eb ;bdlc data register
00ec                    DLCBARD:        equ REGBASE+$ec ;bdlc analog delay register
00ed                    DLCBRSR:        equ REGBASE+$ed ;bdlc rate select register
00ee                    DLCSCR:                equ REGBASE+$ee ;bdlc control register
00ef                    DLCBSTAT:        equ REGBASE+$ef ;bdlc status register
                        
00f0                    SPI1CR1:        equ REGBASE+$f0 ;spi 1 control1 reg
00f1                    SPI1CR2:        equ REGBASE+$f1 ;spi 1 control2 reg
00f2                    SPI1BR:         equ REGBASE+$f2 ;spi 1 baud reg
00f3                    SPI1SR:         equ REGBASE+$f3 ;spi 1 status reg hi
00f5                    SPI1DR:          equ REGBASE+$f5 ;spi 1 data reg
00f5                    SP1DR:          equ REGBASE+$f5 ;spi 1 data reg   FOR COMPATIBILITY
                        
00f8                    SPI2CR1:        equ REGBASE+$f8 ;spi 2 control1 reg
00f9                    SPI2CR2:        equ REGBASE+$f9 ;spi 2 control2 reg
00fa                    SPI2BR:         equ REGBASE+$fa ;spi 2 baud reg
00fb                    SPI2SR:         equ REGBASE+$fb ;spi 2 status reg hi
00fd                    SPI2DR:         equ REGBASE+$fd ;spi 2 data reg
00fd                    SP2DR:          equ REGBASE+$fd ;spi 2 data reg   FOR COMPATIBILITY
                        
0100                    FCLKDIV:        equ REGBASE+$100 ;flash clock divider
0101                    FSEC:                equ REGBASE+$101 ;flash security register
                        
0103                    FCNFG:                equ REGBASE+$103 ;flash configuration register
0104                    FPROT:                equ REGBASE+$104 ;flash protection register
0105                    FSTAT:                equ REGBASE+$105 ;flash status register
0106                    FCMD:                equ REGBASE+$106 ;flash command register
                        
0110                    ECLKDIV:        equ REGBASE+$110 ;eeprom clock divider
                        
0113                    ECNFG:                equ REGBASE+$113 ;eeprom configuration register
0114                    EPROT:                equ REGBASE+$114 ;eeprom protection register
0115                    ESTAT:                equ REGBASE+$115 ;eeprom status register
0116                    ECMD:                equ REGBASE+$116 ;eeprom command register
                        
0120                    ATD1CTL0:       equ REGBASE+$120 ;adc1 control 0 (reserved)
0121                    ATD1CTL1:       equ REGBASE+$121 ;adc1 control 1 (reserved)
0122                    ATD1CTL2:       equ REGBASE+$122 ;adc1 control 2
0123                    ATD1CTL3:       equ REGBASE+$123 ;adc1 control 3
0124                    ATD1CTL4:       equ REGBASE+$124 ;adc1 control 4
0125                    ATD1CTL5:       equ REGBASE+$125 ;adc1 control 5
0126                    ATD1STAT0:      equ REGBASE+$126 ;adc1 status register hi
012b                    ATD1STAT1:      equ REGBASE+$12b ;adc1 status register lo
0128                    ATD1TEST:       equ REGBASE+$128 ;adc1 test (reserved)
                        *atd1test       equ REGBASE+$129 ;
                        
012d                    ATDDIEN:        equ REGBASE+$12d ;adc1 input enable register
                        
012f                    PORTAD1:        equ REGBASE+$12f ;port adc1 = input only
0130                    ADR10H:         equ REGBASE+$130 ;adc1 result 0 register
0132                    ADR11H:         equ REGBASE+$132 ;adc1 result 1 register
0134                    ADR12H:         equ REGBASE+$134 ;adc1 result 2 register
0136                    ADR13H:         equ REGBASE+$136 ;adc1 result 3 register
0138                    ADR14H:         equ REGBASE+$138 ;adc1 result 4 register
013a                    ADR15H:         equ REGBASE+$13a ;adc1 result 5 register
013c                    ADR16H:         equ REGBASE+$13c ;adc1 result 6 register
013e                    ADR17H:         equ REGBASE+$13e ;adc1 result 7 register
                        
0140                    CAN0CTL0:        equ REGBASE+$140 ;can0 control register 0
0141                    CAN0CTL1:        equ REGBASE+$141 ;can0 control register 1
0142                    CAN0BTR0:        equ REGBASE+$142 ;can0 bus timing register 0
0143                    CAN0BTR1:        equ REGBASE+$143 ;can0 bus timing register 1
0144                    CAN0RFLG:        equ REGBASE+$144 ;can0 receiver flags
0145                    CAN0RIER:        equ REGBASE+$145 ;can0 receiver interrupt enables
0146                    CAN0TFLG:        equ REGBASE+$146 ;can0 transmit flags
0147                    CAN0TIER:        equ REGBASE+$147 ;can0 transmit interrupt enables
0148                    CAN0TARQ:        equ REGBASE+$148 ;can0 transmit message abort control
0149                    CAN0TAAK:        equ REGBASE+$149 ;can0 transmit message abort status
014a                    CAN0TBEL:        equ REGBASE+$14a ;can0 transmit buffer select
014b                    CAN0IDAC:        equ REGBASE+$14b ;can0 identfier acceptance control
                        
014e                    CAN0RERR:        equ REGBASE+$14e ;can0 receive error counter
014f                    CAN0TERR:        equ REGBASE+$14f ;can0 transmit error counter
0150                    CAN0IDA0:        equ REGBASE+$150 ;can0 identifier acceptance register 0
0151                    CAN0IDA1:        equ REGBASE+$151 ;can0 identifier acceptance register 1
0152                    CAN0IDA2:        equ REGBASE+$152 ;can0 identifier acceptance register 2
0153                    CAN0IDA3:        equ REGBASE+$153 ;can0 identifier acceptance register 3
0154                    CAN0IDM0:        equ REGBASE+$154 ;can0 identifier mask register 0
0155                    CAN0IDM1:        equ REGBASE+$155 ;can0 identifier mask register 1
0156                    CAN0IDM2:        equ REGBASE+$156 ;can0 identifier mask register 2
0157                    CAN0IDM3:        equ REGBASE+$157 ;can0 identifier mask register 3
0158                    CAN0IDA4:        equ REGBASE+$158 ;can0 identifier acceptance register 4
0159                    CAN0IDA5:        equ REGBASE+$159 ;can0 identifier acceptance register 5
015a                    CAN0IDA6:        equ REGBASE+$15a ;can0 identifier acceptance register 6
015b                    CAN0IDA7:        equ REGBASE+$15b ;can0 identifier acceptance register 7
015c                    CAN0IDM4:        equ REGBASE+$15c ;can0 identifier mask register 4
015d                    CAN0IDM5:        equ REGBASE+$15d ;can0 identifier mask register 5
015e                    CAN0IDM6:        equ REGBASE+$15e ;can0 identifier mask register 6
015f                    CAN0IDM7:        equ REGBASE+$15f ;can0 identifier mask register 7
0160                    CAN0RXFG:        equ REGBASE+$160 ;can0 rx foreground buffer thru +$16f
0170                    CAN0TXFG:        equ REGBASE+$170 ;can0 tx foreground buffer thru +$17f
                        
0180                    CAN1CTL0:        equ REGBASE+$180 ;can1 control register 0
0181                    CAN1CTL1:        equ REGBASE+$181 ;can1 control register 1
0182                    CAN1BTR0:        equ REGBASE+$182 ;can1 bus timing register 0
0183                    CAN1BTR1:        equ REGBASE+$183 ;can1 bus timing register 1
0184                    CAN1RFLG:        equ REGBASE+$184 ;can1 receiver flags
0185                    CAN1RIER:        equ REGBASE+$185 ;can1 receiver interrupt enables
0186                    CAN1TFLG:        equ REGBASE+$186 ;can1 transmit flags
0187                    CAN1TIER:        equ REGBASE+$187 ;can1 transmit interrupt enables
0188                    CAN1TARQ:        equ REGBASE+$188 ;can1 transmit message abort control
0189                    CAN1TAAK:        equ REGBASE+$189 ;can1 transmit message abort status
018a                    CAN1TBEL:        equ REGBASE+$18a ;can1 transmit buffer select
018b                    CAN1IDAC:        equ REGBASE+$18b ;can1 identfier acceptance control
                        
018e                    CAN1RERR:        equ REGBASE+$18e ;can1 receive error counter
018f                    CAN1TERR:        equ REGBASE+$18f ;can1 transmit error counter
0190                    CAN1IDA0:        equ REGBASE+$190 ;can1 identifier acceptance register 0
0191                    CAN1IDA1:        equ REGBASE+$191 ;can1 identifier acceptance register 1
0192                    CAN1IDA2:        equ REGBASE+$192 ;can1 identifier acceptance register 2
0193                    CAN1IDA3:        equ REGBASE+$193 ;can1 identifier acceptance register 3
0194                    CAN1IDM0:        equ REGBASE+$194 ;can1 identifier mask register 0
0195                    CAN1IDM1:        equ REGBASE+$195 ;can1 identifier mask register 1
0196                    CAN1IDM2:        equ REGBASE+$196 ;can1 identifier mask register 2
0197                    CAN1IDM3:        equ REGBASE+$197 ;can1 identifier mask register 3
0198                    CAN1IDA4:        equ REGBASE+$198 ;can1 identifier acceptance register 4
0199                    CAN1IDA5:        equ REGBASE+$199 ;can1 identifier acceptance register 5
019a                    CAN1IDA6:        equ REGBASE+$19a ;can1 identifier acceptance register 6
019b                    CAN1IDA7:        equ REGBASE+$19b ;can1 identifier acceptance register 7
019c                    CAN1IDM4:        equ REGBASE+$19c ;can1 identifier mask register 4
019d                    CAN1IDM5:        equ REGBASE+$19d ;can1 identifier mask register 5
019e                    CAN1IDM6:        equ REGBASE+$19e ;can1 identifier mask register 6
019f                    CAN1IDM7:        equ REGBASE+$19f ;can1 identifier mask register 7
01a0                    CAN1RXFG:        equ REGBASE+$1a0 ;can1 rx foreground buffer thru +$1af
01b0                    CAN1TXFG:        equ REGBASE+$1b0 ;can1 tx foreground buffer thru +$1bf
                        
01c0                    CAN2CTL0:        equ REGBASE+$1c0 ;can2 control register 0
01c1                    CAN2CTL1:        equ REGBASE+$1c1 ;can2 control register 1
01c2                    CAN2BTR0:        equ REGBASE+$1c2 ;can2 bus timing register 0
01c3                    CAN2BTR1:        equ REGBASE+$1c3 ;can2 bus timing register 1
01c4                    CAN2RFLG:        equ REGBASE+$1c4 ;can2 receiver flags
01c5                    CAN2RIER:        equ REGBASE+$1c5 ;can2 receiver interrupt enables
01c6                    CAN2TFLG:        equ REGBASE+$1c6 ;can2 transmit flags
01c7                    CAN2TIER:        equ REGBASE+$1c7 ;can2 transmit interrupt enables
01c8                    CAN2TARQ:        equ REGBASE+$1c8 ;can2 transmit message abort control
01c9                    CAN2TAAK:        equ REGBASE+$1c9 ;can2 transmit message abort status
01ca                    CAN2TBEL:        equ REGBASE+$1ca ;can2 transmit buffer select
01cb                    CAN2IDAC:        equ REGBASE+$1cb ;can2 identfier acceptance control
                        
01ce                    CAN2RERR:        equ REGBASE+$1ce ;can2 receive error counter
01cf                    CAN2TERR:        equ REGBASE+$1cf ;can2 transmit error counter
01d0                    CAN2IDA0:        equ REGBASE+$1d0 ;can2 identifier acceptance register 0
01d1                    CAN2IDA1:        equ REGBASE+$1d1 ;can2 identifier acceptance register 1
01d2                    CAN2IDA2:        equ REGBASE+$1d2 ;can2 identifier acceptance register 2
01d3                    CAN2IDA3:        equ REGBASE+$1d3 ;can2 identifier acceptance register 3
01d4                    CAN2IDM0:        equ REGBASE+$1d4 ;can2 identifier mask register 0
01d5                    CAN2IDM1:        equ REGBASE+$1d5 ;can2 identifier mask register 1
01d6                    CAN2IDM2:        equ REGBASE+$1d6 ;can2 identifier mask register 2
01d7                    CAN2IDM3:        equ REGBASE+$1d7 ;can2 identifier mask register 3
01d8                    CAN2IDA4:        equ REGBASE+$1d8 ;can2 identifier acceptance register 4
01d9                    CAN2IDA5:        equ REGBASE+$1d9 ;can2 identifier acceptance register 5
01da                    CAN2IDA6:        equ REGBASE+$1da ;can2 identifier acceptance register 6
01db                    CAN2IDA7:        equ REGBASE+$1db ;can2 identifier acceptance register 7
01dc                    CAN2IDM4:        equ REGBASE+$1dc ;can2 identifier mask register 4
01dd                    CAN2IDM5:        equ REGBASE+$1dd ;can2 identifier mask register 5
01de                    CAN2IDM6:        equ REGBASE+$1de ;can2 identifier mask register 6
01df                    CAN2IDM7:        equ REGBASE+$1df ;can2 identifier mask register 7
01e0                    CAN2RXFG:        equ REGBASE+$1e0 ;can2 rx foreground buffer thru +$1ef
01f0                    CAN2TXFG:        equ REGBASE+$1f0 ;can2 tx foreground buffer thru +$1ff
                        
0200                    CAN3CTL0:        equ REGBASE+$200 ;can3 control register 0
0201                    CAN3CTL1:        equ REGBASE+$201 ;can3 control register 1
0202                    CAN3BTR0:        equ REGBASE+$202 ;can3 bus timing register 0
0203                    CAN3BTR1:        equ REGBASE+$203 ;can3 bus timing register 1
0204                    CAN3RFLG:        equ REGBASE+$204 ;can3 receiver flags
0205                    CAN3RIER:        equ REGBASE+$205 ;can3 receiver interrupt enables
0206                    CAN3TFLG:        equ REGBASE+$206 ;can3 transmit flags
0207                    CAN3TIER:        equ REGBASE+$207 ;can3 transmit interrupt enables
0208                    CAN3TARQ:        equ REGBASE+$208 ;can3 transmit message abort control
0209                    CAN3TAAK:        equ REGBASE+$209 ;can3 transmit message abort status
020a                    CAN3TBEL:        equ REGBASE+$20a ;can3 transmit buffer select
020b                    CAN3IDAC:        equ REGBASE+$20b ;can3 identfier acceptance control
                        
020e                    CAN3RERR:        equ REGBASE+$20e ;can3 receive error counter
020f                    CAN3TERR:        equ REGBASE+$20f ;can3 transmit error counter
0210                    CAN3IDA0:        equ REGBASE+$210 ;can3 identifier acceptance register 0
0211                    CAN3IDA1:        equ REGBASE+$211 ;can3 identifier acceptance register 1
0212                    CAN3IDA2:        equ REGBASE+$212 ;can3 identifier acceptance register 2
0213                    CAN3IDA3:        equ REGBASE+$213 ;can3 identifier acceptance register 3
0214                    CAN3IDM0:        equ REGBASE+$214 ;can3 identifier mask register 0
0215                    CAN3IDM1:        equ REGBASE+$215 ;can3 identifier mask register 1
0216                    CAN3IDM2:        equ REGBASE+$216 ;can3 identifier mask register 2
0217                    CAN3IDM3:        equ REGBASE+$217 ;can3 identifier mask register 3
0218                    CAN3IDA4:        equ REGBASE+$218 ;can3 identifier acceptance register 4
0219                    CAN3IDA5:        equ REGBASE+$219 ;can3 identifier acceptance register 5
021a                    CAN3IDA6:        equ REGBASE+$21a ;can3 identifier acceptance register 6
021b                    CAN3IDA7:        equ REGBASE+$21b ;can3 identifier acceptance register 7
021c                    CAN3IDM4:        equ REGBASE+$21c ;can3 identifier mask register 4
021d                    CAN3IDM5:        equ REGBASE+$21d ;can3 identifier mask register 5
021e                    CAN3IDM6:        equ REGBASE+$21e ;can3 identifier mask register 6
021f                    CAN3IDM7:        equ REGBASE+$21f ;can3 identifier mask register 7
0220                    CAN3RXFG:        equ REGBASE+$220 ;can3 rx foreground buffer thru +$22f
0230                    CAN3TXFG:        equ REGBASE+$230 ;can3 tx foreground buffer thru +$23f
                        
0240                    PTT:                equ REGBASE+$240 ;portt data register
0241                    PTIT:                equ REGBASE+$241 ;portt input register
0242                    DDRT:                equ REGBASE+$242 ;portt direction register
0243                    RDRT:                equ REGBASE+$243 ;portt reduced drive register
0244                    PERT:                equ REGBASE+$244 ;portt pull device enable
0245                    PPST:                equ REGBASE+$245 ;portt pull polarity select
                        
0248                    PTS:                equ REGBASE+$248 ;ports data register
0249                    PTIS:                equ REGBASE+$249 ;ports input register
024a                    DDRS:                equ REGBASE+$24a ;ports direction register
024b                    RDRS:                equ REGBASE+$24b ;ports reduced drive register
024c                    PERS:                equ REGBASE+$24c ;ports pull device enable
024d                    PPSS:                equ REGBASE+$24d ;ports pull polarity select
024e                    WOMS:                equ REGBASE+$24e ;ports wired or mode register
                        
0250                    PTM:                equ REGBASE+$250 ;portm data register
0251                    PTIM:                equ REGBASE+$251 ;portm input register
0252                    DDRM:                equ REGBASE+$252 ;portm direction register
0253                    RDRM:                equ REGBASE+$253 ;portm reduced drive register
0254                    PERM:                equ REGBASE+$254 ;portm pull device enable
0255                    PPSM:                equ REGBASE+$255 ;portm pull polarity select
0256                    WOMM:                equ REGBASE+$256 ;portm wired or mode register
0257                    MODRR:                equ REGBASE+$257 ;portm module routing register
                        
0258                    PTP:                equ REGBASE+$258 ;portp data register
0259                    PTIP:                equ REGBASE+$259 ;portp input register
025a                    DDRP:                equ REGBASE+$25a ;portp direction register
025b                    RDRP:                equ REGBASE+$25b ;portp reduced drive register
025c                    PERP:                equ REGBASE+$25c ;portp pull device enable
025d                    PPSP:                equ REGBASE+$25d ;portp pull polarity select
025e                    PIEP:                equ REGBASE+$25e ;portp interrupt enable register
025f                    PIFP:                equ REGBASE+$25f ;portp interrupt flag register
                        
0260                    PTH:                equ REGBASE+$260 ;porth data register
0261                    PTIH:                equ REGBASE+$261 ;porth input register
0262                    DDRH:                equ REGBASE+$262 ;porth direction register
0263                    RDRH:                equ REGBASE+$263 ;porth reduced drive register
0264                    PERH:                equ REGBASE+$264 ;porth pull device enable
0265                    PPSH:                equ REGBASE+$265 ;porth pull polarity select
0266                    PIEH:                equ REGBASE+$266 ;porth interrupt enable register
0267                    PIFH:                equ REGBASE+$267 ;porth interrupt flag register
                        
0268                    PTJ:                equ REGBASE+$268 ;portj data register
0269                    PTIJ:                equ REGBASE+$269 ;portj input register
026a                    DDRJ:                equ REGBASE+$26a ;portj direction register
026b                    RDRJ:                equ REGBASE+$26b ;portj reduced drive register
026c                    PERJ:                equ REGBASE+$26c ;portj pull device enable
026d                    PPSJ:                equ REGBASE+$26d ;portj pull polarity select
026e                    PIEJ:                equ REGBASE+$26e ;portj interrupt enable register
026f                    PIFJ:                equ REGBASE+$26f ;portj interrupt flag register
                        
0280                    CAN4CTL0:        equ REGBASE+$280 ;can4 control register 0
0281                    CAN4CTL1:        equ REGBASE+$281 ;can4 control register 1
0282                    CAN4BTR0:        equ REGBASE+$282 ;can4 bus timing register 0
0283                    CAN4BTR1:        equ REGBASE+$283 ;can4 bus timing register 1
0284                    CAN4RFLG:        equ REGBASE+$284 ;can4 receiver flags
0285                    CAN4RIER:        equ REGBASE+$285 ;can4 receiver interrupt enables
0286                    CAN4TFLG:        equ REGBASE+$286 ;can4 transmit flags
0287                    CAN4TIER:        equ REGBASE+$287 ;can4 transmit interrupt enables
0288                    CAN4TARQ:        equ REGBASE+$288 ;can4 transmit message abort control
0289                    CAN4TAAK:        equ REGBASE+$289 ;can4 transmit message abort status
028a                    CAN4TBEL:        equ REGBASE+$28a ;can4 transmit buffer select
028b                    CAN4IDAC:        equ REGBASE+$28b ;can4 identfier acceptance control
                        
028e                    CAN4RERR:        equ REGBASE+$28e ;can4 receive error counter
028f                    CAN4TERR:        equ REGBASE+$28f ;can4 transmit error counter
0290                    CAN4IDA0:        equ REGBASE+$290 ;can4 identifier acceptance register 0
0291                    CAN4IDA1:        equ REGBASE+$291 ;can4 identifier acceptance register 1
0292                    CAN4IDA2:        equ REGBASE+$292 ;can4 identifier acceptance register 2
0293                    CAN4IDA3:        equ REGBASE+$293 ;can4 identifier acceptance register 3
0294                    CAN4IDM0:        equ REGBASE+$294 ;can4 identifier mask register 0
0295                    CAN4IDM1:        equ REGBASE+$295 ;can4 identifier mask register 1
0296                    CAN4IDM2:        equ REGBASE+$296 ;can4 identifier mask register 2
0297                    CAN4IDM3:        equ REGBASE+$297 ;can4 identifier mask register 3
0298                    CAN4IDA4:        equ REGBASE+$298 ;can4 identifier acceptance register 4
0299                    CAN4IDA5:        equ REGBASE+$299 ;can4 identifier acceptance register 5
029a                    CAN4IDA6:        equ REGBASE+$29a ;can4 identifier acceptance register 6
029b                    CAN4IDA7:        equ REGBASE+$29b ;can4 identifier acceptance register 7
029c                    CAN4IDM4:        equ REGBASE+$29c ;can4 identifier mask register 4
029d                    CAN4IDM5:        equ REGBASE+$29d ;can4 identifier mask register 5
029e                    CAN4IDM6:        equ REGBASE+$29e ;can4 identifier mask register 6
029f                    CAN4IDM7:        equ REGBASE+$29f ;can4 identifier mask register 7
02a0                    CAN4RXFG:        equ REGBASE+$2a0 ;can4 rx foreground buffer thru +$2af
02b0                    CAN4TXFG:        equ REGBASE+$2b0 ;can4 tx foreground buffer thru +$2bf
                        
                        * end registers
                        #endinclude

                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                       DECLARACION VECTORES INTERRUPCION
                        ;*******************************************************************************
                                ; Vector interrupcion output compare canal 4
3e66                            ORG $3e66
3e66 24 30                      dw OC4_ISR
                                
                                ; Vector interrupcion del real time interrupt
3e70                            ORG $3e70
3e70 23 f6                      dw RTI_ISR
                                
                                ; Vector de interrupcion de key wakeups
3e4c                            ORG $3e4c
3e4c 24 02                      dw PHO_ISR
                                
3e52                            ORG $3E52       ;ATD
3e52 24 c1                      dw ATD_ISR
                        
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;-------------------------------------------------------------------------------
                        ;--------------------------------------MAIN-------------------------------------
                        ;-------------------------------------------------------------------------------
                        ;*******************************************************************************
                        
2000                            ORG $2000
2000 cf 3b ff                   LDS #$3BFF
                        ;INICIALIZACION DE HARDWARE:
                                ; Inicializacion de CAD
2003 18 0b 82 00 82             movb #$82,ATD0CTL2      ; Activa el ATD y las interrupciones
2008 86 50                      ldaa #80
200a                    ATD_wait:
200a 04 30 fd                   dbne a,ATD_wait          ;Espera 10us
200d 18 0b 30 00 83             movb #%00110000,ATD0CTL3      ; 6 conversiones por canal
2012 18 0b b7 00 84             movb #%10110111,ATD0CTL4      ; Define frecuencia en 500KHz y 4 periodos del itempo de muestreo
2017 18 0b 87 00 85             movb #%10000111,ATD0CTL5      ; comienza lectura de ATD con los datos justificados y eligiendo la entrada 7 donde esta el pot
                                ;subrutina mux_teclado:
201c 18 0b 01 00 0c             MOVB #$01,PUCR       ;Resistencias pull up
2021 18 0b f0 00 02             MOVB #$F0,DDRA      ;Puerto A, parte alta salidas, parte baja entradas
                                
                                ;subrutina RTI_ISR:
2026 18 0b 23 00 3b             movb #$23,RTICTL        ; M = 2 n = 3
202b 4c 38 80                   bset CRGINT,#$80        ; activa rti
                                
                                ;subrutina PHO_ISR:
202e 1c 02 66 0f                bset PIEH,$0F           ; Activando interrupcion PH0,PH1,PH2,PH3,
                        
                                ;Inicializacion de Output compare canal 4 y Timmer overflow interrupt.
2032 4c 46 90                   BSET TSCR1,$90 ; TEN = 1 , TFFCA = 1. Habilitando modulo timers y el borrado rapido
2035 4c 4d 03                   BSET TSCR2, $03 ;BSET TSCR2, $83 Preescalador = 8 y activando timer overflow interrupt , al final de esta subr leer tcnt
                        
2038 4c 4c 10                   BSET TIE,$10    ; Habilitando interrupcion output compare canal 4
203b 4c 40 10                   BSET TIOS,$10   ; Pone como salida canal 4
                        
                                
                                ; Inicializacion de Puerto B y P para uso de los display de 7 seg.
203e 18 0b ff 00 03             MOVB #$FF,DDRB            ; Todas salidas puerto B (segentos de display)
2043 18 0b 0f 02 5a             MOVB #$0F,DDRP            ; 4 salidas puerto P (activan cada display)
                        
                                ;Inicializacion puerto J para usar leds
2048 1c 02 6a 02                bset DDRJ,$02             ; Salida puerto j
                        
                                ; Inicializacion del relay
204c 4c 09 04                   BSET    DDRE,%00000100     ;PE2 salida para rele
                        
                                ; Pantalla LED
204f 18 0b ff 00 33             MOVB #$FF,DDRK  ; Puerto K como salidas
                                
                        ;INICIALIZACION DE VARIABLES:
2054 10 ef                      CLI                     ; Activando interrupciones
2056 18 0b ff 10 01             MOVB #$FF,TECLA
205b 18 0b ff 10 02             MOVB #$FF,TECLA_IN
2060 79 10 03                   CLR CONT_REB
2063 79 10 06                   CLR BANDERAS
2066 1c 10 06 10                BSET BANDERAS,$10       ; Poniendo el sistema en modo CONFIG
206a 79 10 04                   CLR CONT_TCL
                                ; DISPLAYS
206d 79 10 09                   CLR CPROG
2070 79 10 0e                   CLR CONT_DIG
2073 79 10 0f                   CLR CONT_TICKS
2076 79 10 0d                   CLR BRILLO
2079 79 10 21                   CLR BIN1
207c 79 10 22                   CLR BIN2
207f 18 03 00 00 10 18          MOVW #0,CONT_7SEG
                        
2085 dc 44                      LDD TCNT        ; Inicializa TC4  , esto va mas abajo
2087 c3 00 3c                   ADDD #60
208a 5c 58                      STD TC4
                        
208c 16 21 07                   jsr LCD
                                
208f                    M_loop:
208f f7 10 09                   TST CPROG                 ; Si cprog es 0, solo llama a modo_config
2092 27 40                      Beq cargar_lcd_modo_cprog:
2094 1e 02 61 80 06             BRSET PTIH,$80,modsel_es_0 ; Revisando por pulling el modo (config o run(
2099 1d 10 06 10                BCLR BANDERAS,$10
209d 20 04                      BRA contin_main
209f                    modsel_es_0:
209f 1c 10 06 10                BSET BANDERAS,$10
20a3                    contin_main:
20a3 1e 10 06 10 52             BRSET BANDERAS,$10,cprog_listo    ; Salta si ya CPROG se configuro
20a8 1e 10 06 08 12             BRset BANDERAS,$08,invocar_run    ; Salta si se esta en modo config
20ad 1c 10 06 08                Bset BANDERAS,$08                 ; Cambio modo
20b1 18 0b 01 10 0c             MOVB #$01,LEDS                    ; Cambian leds por el modo
20b6 ce 10 8b                   LDX #Msj_run_1
20b9 cd 10 97                   LDY #Msj_run_2
20bc 16 21 7c                   JSR CARGAR_LCD
20bf                    invocar_run:
20bf 16 22 1b                   JSR MODO_RUN
20c2 b6 10 07                   LDAA CUENTA                     ; Verificando si se debe activar el rele
20c5 b1 10 09                   CMPA CPROG
20c8 27 05                      BEQ act_rele
20ca 4d 08 04                   BCLR PORTE,%00000100           ;Desactivando rele
20cd 20 33                      bra bin_a_bcd
20cf                    act_rele:
20cf 4c 08 04                   BSET PORTE,%00000100           ;Activando rele
20d2 20 2e                      bra bin_a_bcd
                        
20d4                    cargar_lcd_modo_cprog:
20d4 79 10 09                   CLR CPROG            ; Reiniciando valores por el cambio de modo run a config
20d7 79 10 07                   CLR CUENTA
20da 79 10 08                   CLR ACUMUL
20dd 4d 08 04                   BCLR PORTE,%00000100 ;desactivando rele
20e0 79 10 21                   clr bin1
20e3 1d 10 06 08                BCLR BANDERAS,$08
20e7 18 0b 02 10 0c             MOVB #$02,LEDS
20ec ce 10 70                   LDX #Msj_config_1
20ef cd 10 7c                   LDY #Msj_config_2
20f2 16 21 7c                   JSR CARGAR_LCD
20f5 16 21 d9                   JSR MODO_CONFIG
20f8 20 08                      BRA bin_a_bcd
20fa                    cprog_listo:
20fa 1e 10 06 08 d5             BRSET BANDERAS,$08,cargar_lcd_modo_cprog   ; Verificando cambio modo
20ff                    Mod_conf:
20ff 16 21 d9                   JSR MODO_CONFIG
2102                    bin_a_bcd:
2102 16 22 86                   JSR CONV_BIN_BCD
2105 20 88                      BRA M_loop                    ; Comenzar de nuevo
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        ;*******************************************************************************
                        ;                             SUBRUTINA LCD
                        ;*******************************************************************************
                        ;Descripcion: Esta subrutina inicializa la subrutina LCD
2107                    LCD:
2107 ce 10 60                   LDX #iniDsp
210a                    Loop_lcd_inic:
210a a6 30                      LDAA 1,X+
210c 81 ff                      CMPA #EOM
210e 27 12                      BEQ FIN_Loop_lcd_inic
2110 1d 10 06 80                BCLR BANDERAS, $80            ; para mandar un comando
2114 16 21 35                   JSR SEND
2117 18 0c 10 1d 10 1a          MOVB D60uS,CONT_DELAY
211d 16 21 d3                   JSR DELAY
2120 20 e8                      BRA Loop_lcd_inic
2122                    FIN_Loop_lcd_inic:
2122 86 01                      LDAA #$01              ; CLEAR DISPLAY
2124 1d 10 06 80                BCLR BANDERAS, $80            ; para mandar un comando
2128 16 21 35                   JSR SEND
212b 18 0c 10 1b 10 1a          MOVB D2ms,CONT_DELAY
2131 16 21 d3                   JSR DELAY
2134 3d                         RTS
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                             SUBRUTINA SEND
                        ;*******************************************************************************
                        ;Descripcion: Esta subrutina envia datos o comandos a pantalla LCD, recibe como
                        ; parametro la bandera COMANDO_DATO en 0 si es comando, 1 si es dato
                        
2135                    SEND:
2135 36                         PSHA
2136 84 f0                      andA #$F0
2138 44                         LSRA
2139 44                         LSRA
213a 5a 32                      STAA PORTK
213c 1f 10 06 80 05             BRCLR BANDERAS,$80,SEND_comando  ; 0 COMANDO, 1 DATO
2141 4c 32 01                   BSET PORTK,$01
2144 20 03                      BRA SEND_continuar
2146                    SEND_comando:
2146 4d 32 01                   BCLR PORTK,$01
2149                    SEND_continuar:
2149 4c 32 02                   BSET PORTK,$02
214c 18 0c 10 1c 10 1a          MOVB D260us,CONT_DELAY
2152 16 21 d3                   JSR DELAY
2155 4d 32 02                   BCLR PORTK,$02
                        
2158 32                         PULA
2159 84 0f                      andA #$0F
215b 48                         LSLA
215c 48                         LSLA
215d 5a 32                      STAA PORTK
215f 1f 10 06 80 05             BRCLR BANDERAS,$80,SEND_comando2  ; 0 COMANDO, 1 DATO
2164 4c 32 01                   BSET PORTK,$01
2167 20 03                      BRA SEND_continuar2
2169                    SEND_comando2:
2169 4d 32 01                   BCLR PORTK,$01
216c                    SEND_continuar2:
216c 4c 32 02                   BSET PORTK,$02
216f 18 0c 10 1c 10 1a          MOVB D260us,CONT_DELAY
2175 16 21 d3                   JSR DELAY
2178 4d 32 02                   BCLR PORTK,$02
217b 3d                         RTS
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                             SUBRUTINA CARGAR_LCD
                        ;*******************************************************************************
                        ;Descripcion: Esta subrutina carga los mensajes en la LCD
                        
217c                    CARGAR_LCD:
217c b6 10 1f                   LDAA ADD_L1
217f 1d 10 06 80                BCLR BANDERAS, $80            ; para mandar un comando
2183 16 21 35                   JSR SEND
2186 18 0c 10 1d 10 1a          MOVB D60uS,CONT_DELAY
218c 16 21 d3                   JSR DELAY
218f                    CARGAR_LCD_first_loop:
218f a6 30                      LDAA 1,X+
2191 81 ff                      CMPA #EOM
2193 27 12                      BEQ CARGAR_LCD_first_loop_end
2195 1c 10 06 80                BSET BANDERAS, $80            ; para mandar un dato
2199 16 21 35                   JSR SEND
219c 18 0c 10 1d 10 1a          MOVB D60uS,CONT_DELAY
21a2 16 21 d3                   JSR DELAY
21a5 20 e8                      BRA CARGAR_LCD_first_loop
21a7                    CARGAR_LCD_first_loop_end:
21a7 b6 10 20                   LDAA ADD_L2
21aa 1d 10 06 80                BCLR BANDERAS, $80            ; para mandar un comando
21ae 16 21 35                   JSR SEND
21b1 18 0c 10 1d 10 1a          MOVB D60uS,CONT_DELAY
21b7 16 21 d3                   JSR DELAY
                                
21ba                    CARGAR_LCD_SECOND_loop:
21ba a6 70                      LDAA 1,Y+
21bc 81 ff                      CMPA #EOM
21be 27 12                      BEQ CARGAR_LCD_SECOND_loop_end
21c0 1c 10 06 80                BSET BANDERAS, $80            ; para mandar un dato
21c4 16 21 35                   JSR SEND
21c7 18 0c 10 1d 10 1a          MOVB D60uS,CONT_DELAY
21cd 16 21 d3                   JSR DELAY
21d0 20 e8                      BRA CARGAR_LCD_SECOND_loop
21d2                    CARGAR_LCD_SECOND_loop_end:
21d2 3d                         RTS
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                             SUBRUTINA DELAY
                        ;*******************************************************************************
                        ;Descripcion: Esta subrutina se encarga de generar delays a partir de la variable
                        ;CONT_DELAY. Por ejemplo un valor de CONT_DELAY de 50 da una interrupcion de 1x10-3
                        ; Debido a que cada decremento de CONT_DELAY se da cada 20us
                        
21d3                    DELAY:
21d3 f7 10 1a                   TST CONT_DELAY
21d6 26 fb                      BNE DELAY
21d8 3d                         RTS
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                             SUBRUTINA MODO_CONFIG
                        ;*******************************************************************************
                        ;Descripcion: Esta subrutina se encarga de realizar la logica del modo de confi-
                        ;guracion, principalmente el hecho de guardar el valor ingresado en el teclado en
                        ;CPROG y posteriormente en BIN1. Ademas valida si el valor ingresado por el usua-
                        ;rio es valido (entre 12 y 96).
                        
21d9                    MODO_CONFIG:
21d9 1e 10 06 04 04             BRSET BANDERAS,$04,MODO_CONFIG_tcl_lista ;Verificando si Ya hay una tecla lista
21de 16 22 e5                   JSR TAREA_TECLADO                        ;Leyendo una tecla
21e1 3d                         RTS
21e2                    MODO_CONFIG_tcl_lista: ;Ya hay una tecla lista
21e2 16 21 ff                   JSR BCD_BIN          ;Pasando de BCD a binario
21e5 1d 10 06 04                BCLR BANDERAS,$04   ; Borrando array_ok
21e9 b6 10 09                   LDAA CPROG          ; Verificando si tecla es valida
21ec 81 0c                      CMPA #12
21ee 25 0b                      BLO MODO_CONFIG_tcl_no_valida
21f0 81 60                      CMPA #96
21f2 22 07                      BHI MODO_CONFIG_tcl_no_valida
21f4 18 0c 10 09 10 21          MOVB CPROG,BIN1     ; Pasando el valor programado a BIN1
21fa 3d                         RTS
21fb                    MODO_CONFIG_tcl_no_valida:
21fb 79 10 09                   CLR CPROG           ; Valor no valido
21fe 3d                         RTS
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                             SUBRUTINA BCD_BIN
                        ;*******************************************************************************
                        ;Descripcion: Esta subrutina se encarga de realizar la conversion de los numeros
                        ; leidos en el teclado a binario y guardarlo en CPROG.
21ff                    BCD_BIN:
21ff ce 10 30                   LDX #NUM_ARRAY
2202 86 0a                      LDAA #10
2204 e6 30                      LDAB 1,X+
2206 12                         MUL             ; NUMERO MAS SIGNIFICATIVO MULTIPLICADO POR 10
2207 a6 00                      LDAA 0,X
2209 81 ff                      CMPA #$FF
220b 27 05                      BEQ BCD_BIN_continuar
220d eb 00                      ADDB 0,X         ; Sumando parte baja
220f 7b 10 09                   STAB CPROG         ; Guardando valor binario en cprog
2212                    BCD_BIN_continuar:
2212 18 08 00 ff                MOVB #$FF,0,X
2216 18 08 2f ff                MOVB #$FF,1,-X
221a 3d                         RTS
                                
                        
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                             SUBRUTINA MODO_RUN
                        ;*******************************************************************************
                        
                        ;Descripcion: Esta subrutina se encarga de hacer todo el control del modo run
                        ; Para mas informacion ver el enunciado de la tarea/
                        
221b                    MODO_RUN:
221b b6 10 09                   LDAA CPROG            ;Verificando Si CPROG = CUENTA
221e b1 10 07                   CMPA CUENTA
2221 27 22                      BEQ MODO_RUN_fin
2223 f7 10 0b                   TST TIMER_CUENTA       ; SI timer cuenta no es 0 aun
2226 26 1d                      BNE MODO_RUN_fin
2228 72 10 07                   INC CUENTA             ; Incrementando cuenta
222b 18 0c 10 0a 10 0b          MOVB VMAX,TIMER_CUENTA ; Recargando Timer_Cuenta
2231 b1 10 07                   CMPA CUENTA
2234 26 0f                      BNE MODO_RUN_fin
2236 86 63                      LDAA #99                      ; RESETEANDO ACUMUL A 0 SI PASA DE 99
2238 b1 10 08                   CMPA ACUMUL
223b 27 05                      BEQ MODO_RUN_resetar_acum
223d 72 10 08                   INC ACUMUL             ; Si CPROG = nueva cuenta
2240 20 03                      BRA MODO_RUN_fin
2242                    MODO_RUN_resetar_acum:
2242 79 10 08                   CLR ACUMUL
2245                    MODO_RUN_fin:                  ; Cargando valores en BIN1 y BIN2
2245 18 0c 10 07 10 21          MOVB CUENTA,BIN1
224b 18 0c 10 08 10 22          MOVB ACUMUL,BIN2
2251 3d                         RTS
                        
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                             SUBRUTINA BIN_BCD
                        ;*******************************************************************************
                        
                        ;Descripcion: Esta subrutina convierte un numero pasado como parametro por el acu-
                        ; mulador A en binario y devuelve su valor en BCD en la variable BCD_L. Utiliza
                        ; Como variables BCD_H y BCD_L
                        
2252                    BIN_BCD:
2252 c6 07                      LDAB #7
2254 79 10 25                   CLR BCD_L
2257                    BIN_BCD_2_main_loop:
2257 48                         LSLA
2258 75 10 25                   ROL BCD_L
225b 36                         PSHA
225c 86 0f                      LDAA #$0F                ; Mascara de BCDX con 0F en A
225e b4 10 25                   ANDA BCD_L
2261 81 05                      CMPA #5                  ; R1 mayor igual 5
2263 25 02                      BLO BIN_BCD2_cont
2265 8b 03                      ADDA #3
2267                    BIN_BCD2_cont:
2267 7a 10 26                   STAA BCD_H      ; UTILIZADO COMO VARIABLE TEMPORAL LOW
226a 86 f0                      LDAA #$F0                ; Mascara de BCDX con F0 en A
226c b4 10 25                   ANDA BCD_L
226f 81 50                      CMPA #$50
2271 25 02                      BLO BIN_BCD2_cont_2
2273 8b 30                      ADDA #$30
2275                    BIN_BCD2_cont_2:
2275 bb 10 26                   ADDA BCD_H      ; BCD_H = LOW
2278 7a 10 25                   STAA BCD_L
227b 32                         PULA
227c 04 01 02                   DBEQ B, BIN_BCD2_fin
227f 20 d6                      BRA BIN_BCD_2_main_loop
2281                    BIN_BCD2_fin:              ; RETORNANDO
2281 48                         LSLA
2282 75 10 25                   ROL BCD_L
2285 3d                         RTS
                                
                        ;*******************************************************************************
                        ;                             SUBRUTINA CONV_BIN_BCD
                        ;*******************************************************************************
                        
                        ;Descripcion: Esta subrutina llama a BIN_BCD y guarda los valores en BCD1 y BCD2
                        
2286                    CONV_BIN_BCD:
2286 b6 10 21                   LDAA BIN1
2289 16 22 52                   JSR BIN_BCD
228c 1f 10 25 f0 02             BRCLR BCD_L,$F0,BIN_BCD_bcd1_borrar2
2291 20 04                      BRA BIN_BCD_continuar2:
2293                    BIN_BCD_bcd1_borrar2:
2293 1c 10 25 f0                BSET BCD_L,$F0             ; Escribiendo un F en parte alta que no es valida
2297                    BIN_BCD_continuar2:                ; Segundo numero
2297 18 0c 10 25 10 12          MOVB BCD_L,BCD1
                        
                                ; Analizando segundo numero
229d b6 10 22                   LDAA BIN2
22a0 16 22 52                   JSR BIN_BCD
22a3 1f 10 25 f0 02             BRCLR BCD_L,$F0,BIN_BCD_bcd1_borrar3
22a8 20 04                      BRA BIN_BCD_continuar3:
22aa                    BIN_BCD_bcd1_borrar3:
22aa 1c 10 25 f0                BSET BCD_L,$F0             ; Escribiendo un F en parte alta que no es valida
22ae                    BIN_BCD_continuar3:                ; Segundo numero
22ae 18 0c 10 25 10 13          MOVB BCD_L,BCD2
22b4 3d                         RTS
                        
                        
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                             SUBRUTINA BCD_7SEG
                        ;*******************************************************************************
                        ;Descripcion: Esta subrutina pasa valores de BCD1 y BCD2 a DISP1,DISP2,DISP3,
                        ; DISP4, en su respectivo codigo de 7 segmentos. Si hay ceros a la izquierda
                        ; se envia un codigo $fx
                        
22b5                    BCD_7SEG:
22b5 ce 10 12                   LDX #BCD1          ;Declaracion punteros iniciales
22b8 cd 10 14                   LDY #DISP1
22bb 86 02                      LDAA #2
22bd                    BCD_7SEG_main_loop:
22bd 27 25                      BEQ BCD_7SEG_FIN
22bf 36                         PSHA
22c0 a6 00                      LDAA 0,X            ; CARGANDO NUMEROS A PROCESAR
22c2 e6 00                      LDAB 0,X
22c4 34                         PSHX
22c5 ce 10 50                   LDX #SEGMENT
22c8 c4 0f                      ANDB #$0F
22ca 18 0a e5 70                MOVB B,X,1,Y+
22ce 44                         LSRA                     ; Analizando segundo nibble
22cf 44                         LSRA
22d0 44                         LSRA
22d1 44                         LSRA
22d2 81 0f                      CMPA #$0F
22d4 27 06                      BEQ BCD_7SEG_CLEAR        ; Si el numero es invalido?
22d6 18 0a e4 70                MOVB A,X,1,Y+
22da 20 02                      BRA BCD_7SEG_CONT
22dc                    BCD_7SEG_CLEAR:
22dc 69 70                      CLR 1,Y+
22de                    BCD_7SEG_CONT:
22de 30                         PULX                         ; Preparando para el sig ciclo
22df 32                         PULA
22e0 08                         INX
22e1 43                         DECA
22e2 20 d9                      BRA BCD_7SEG_main_loop
22e4                    BCD_7SEG_FIN:
22e4 3d                         RTS
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;-------------------------------------------------------------------------------
                        ;-------------------SUBRUTINAS RELACIONADAS A TECLADO---------------------------
                        ;-------------------------------------------------------------------------------
                        ;*******************************************************************************
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                             SUBRUTINA TAREA_TECLADO
                        ;*******************************************************************************
                        ; Descripcion: Esta subrutina se encarga de hacer toda la logica para leer una
                        ; tecla de manera correcta.
22e5                    TAREA_TECLADO:
22e5 ce 10 40                   LDX #TECLAS
22e8 cd 10 30                   LDY #NUM_ARRAY
22eb f7 10 03                   TST CONT_REB
22ee 26 50                      BNE FIN_TAREA_TECLADO
22f0 16 23 88                   JSR MUX_TECLADO
22f3 86 ff                      LDAA #$FF
22f5 b1 10 01                   CMPA TECLA
22f8 27 35                      BEQ TECLA_LISTA_TT
22fa 1e 10 06 02 10             BRSET BANDERAS,$02,TECLA_LEIDA_TT
22ff 18 0c 10 01 10 02          MOVB TECLA, TECLA_IN
2305 1c 10 06 02                BSET BANDERAS,$02       ; TECLA LEIDA = 1
2309 18 0b 0a 10 03             MOVB #10, CONT_REB
230e 3d                         RTS
230f                    TECLA_LEIDA_TT:
230f b6 10 01                   LDAA TECLA
2312 b1 10 02                   CMPA TECLA_IN
2315 27 13                      BEQ PONER_BANDERA_TCL_LISTA
2317 18 0b ff 10 01             MOVB #$FF,TECLA
231c 18 0b ff 10 02             MOVB #$FF,TECLA_IN
2321 1d 10 06 01                BCLR BANDERAS,$01       ; TECLA LISTA = 0
2325 1d 10 06 02                BCLR BANDERAS,$02       ; TECLA LEIDA = 0
2329 3d                         RTS
232a                    PONER_BANDERA_TCL_LISTA:
232a 1c 10 06 01                BSET BANDERAS,$01       ; TECLA LISTA = 1
232e 3d                         RTS
232f                    TECLA_LISTA_TT:
232f 1e 10 06 01 01             BRSET BANDERAS,$01,FORM_ARR_TT ; TECLA LISTA = 1?
2334 3d                         RTS
2335                    FORM_ARR_TT:
2335 1d 10 06 01                BCLR BANDERAS,$01       ; TECLA LISTA = 0
2339 1d 10 06 02                BCLR BANDERAS,$02       ; TECLA LEIDA = 0
233d 16 23 41                   JSR FORMAR_ARRAY
2340                    FIN_TAREA_TECLADO:
2340 3d                         RTS
                        
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                                SUBRUTINA FORMAR_ARRAY
                        ;*******************************************************************************
                        ;Descripcion: Esta subrutina se encarga de formar el array con las teclas presio-
                        ; nadas por el usuario, tambien realiza el control y validacion de las distintas
                        ; teclas presionadas. Al llenar el array esta subrutina pone la bandera ARRAY_OK
                        ; en alto y el CONT_TCL en 0. El arreglo NUM_ARRAY utiliza como byte no valido
                        ; el valor $FF
                        
2341                    FORMAR_ARRAY:
2341 f6 10 04                   LDAB CONT_TCL        ; Cargando valores a utilizar
2344 f1 10 00                   CMPB MAX_TCL         ; Verificando Si ya se leyo la cantidad maxima de digitos
2347 27 30                      BEQ FORMAR_ARRAY_lleno
2349 86 0e                      LDAA #$0E             ; Si la tecla es enter y MAX_TCL != Cont_TCL
234b b1 10 02                   CMPA TECLA_IN
234e 27 10                      BEQ FORMAR_ARRAY_enter_presionado
2350 86 0b                      LDAA #$0B             ; Si la tecla es borrar y MAX_TCL != Cont_TCL
2352 b1 10 02                   CMPA TECLA_IN
2355 27 0d                      BEQ FORMAR_ARRAY_borrar_presionado
2357 18 09 ed 10 02             MOVB TECLA_IN,B,Y     ; Guardando la tecla
235c 72 10 04                   INC CONT_TCL
235f 3d                         RTS
2360                    FORMAR_ARRAY_enter_presionado: ; Se presiono un enter y MAX_TCL != Cont_TCL
2360 04 61 0e                   TBNE B, FORMAR_ARRAY_array_ok ; Si hay al menos 1 digito
2363 3d                         RTS
2364                    FORMAR_ARRAY_borrar_presionado: ; Se presiono un borrar y MAX_TCL != Cont_TCL
2364 04 61 01                   TBNE B, FORMAR_ARRAY_borrar_digito ; Si hay al menos 1 digito
2367 3d                         RTS
2368                    FORMAR_ARRAY_borrar_digito:    ; Borrando un digito
2368 53                         DECB
2369 18 08 ed ff                MOVB #$FF,B,Y
236d 73 10 04                   DEC CONT_TCL
2370 3d                         RTS
2371                    FORMAR_ARRAY_array_ok: ;Validando el array
2371 79 10 04                   CLR CONT_TCL
2374 1c 10 06 04                BSET BANDERAS,$04
2378 3d                         RTS
2379                    FORMAR_ARRAY_lleno:
2379 86 0e                      LDAA #$0E             ; Si la tecla es enter y MAX_TCL = Cont_TCL
237b b1 10 02                   CMPA TECLA_IN
237e 27 f1                      BEQ FORMAR_ARRAY_array_ok
2380 86 0b                      LDAA #$0B             ; Si la tecla es borrar y MAX_TCL = Cont_TCL
2382 b1 10 02                   CMPA TECLA_IN
2385 27 e1                      BEQ FORMAR_ARRAY_borrar_digito
2387 3d                         RTS
                                
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                                SUBRUTINA MUX_TECLADO
                        ;*******************************************************************************
                        ;Descripcion: Esta subrutina se encarga de leer una tecla del teclado de la
                        ; Dragon 12. Utiliza como variable PATRON que es un contador que cuando es mayor
                        ; a 4 (las filas del teclado) se termina la subrutina porque no se leyo ninguna
                        ; tecla. En caso de que se lea una tecla se retorna en la variable TECLA. Si
                        ; no existia una tecla se retorna un $FF en TECLA.
                        
2388                    MUX_TECLADO:
2388 18 0b ff 10 01             MOVB #$FF,TECLA
238d 18 0b 01 10 05             MOVB #1, PATRON               ; Inicializacion de variables
2392 86 ef                      LDAA #$EF
2394                    Loop_filas:
2394 5a 00                      STAA PORTA                                 ; Poniendo en las filas el valor de prueba  (EX,DX,BX,7X)
2396 c6 0a                      LDAB #10            ;Esperando un poquito mientras se escribe PORTA
2398 04 31 fd           wait:   DBNE B,wait         ; Ya que puede dar algunos problemas de temporizacion si no se hace esto
239b f6 10 05                   LDAB PATRON                                ; Si ya se leyeron las 4 filas, termina
239e c1 04                      CMPB #4
23a0 22 27                      BHI FIN_MUX_TECLADO
23a2 c6 03                      LDAB #3
23a4 4f 00 01 10                BRCLR PORTA,$01,Tecla_encontrada           ; Verificando si alguna columna esta en 0
23a8 53                         DECB
23a9 4f 00 02 0b                BRCLR PORTA,$02,Tecla_encontrada
23ad 53                         DECB
23ae 4f 00 04 06                BRCLR PORTA,$04,Tecla_encontrada
23b2 72 10 05                   INC PATRON                                 ; Aumentando para siguiente iteracion
23b5 48                         LSLA                                       ; Desplazando para obtener el siguiente valor en la parte alta del pin A (EX,DX,BX,7X)
23b6 20 dc                      BRA Loop_filas
23b8                    Tecla_encontrada:                                 ; Analizando cual tecla es Mediante la ecuacion: PATRON*3 - (3-Columna)
23b8 b6 10 05                   LDAA PATRON                               ; Esta ecuacion da el indice en el areglo TECLAS
23bb 37                         PSHB                                      ; Guardando para utilizar posteriormente
23bc c6 03                      LDAB #3
23be 12                         MUL
23bf b7 10                      TFR B,A
23c1 33                         PULB                                      ; Restaurando de pila
23c2 18 16                      SBA
23c4 18 0d e4 10 01             MOVB A,X,TECLA
23c9                    FIN_MUX_TECLADO:                                 ; Retornando
23c9 3d                         RTS
                        
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                                SUBRUTINA PATRON_LEDS
                        ;*******************************************************************************
                        ;Descripcion:
                        
                        
23ca                    PATRON_LEDS:
23ca 1e 10 06 40 09             BRSET BANDERAS,$40,PATRON_LEDS_desplazar_leds ; cambiar!!!!, el bit de bandera ALERTA esta en otro lado
23cf 86 07                      LDAA #$07            ; Asegurando que no este puesto el patron de emergencia
23d1 b4 10 0c                   ANDA LEDS
23d4 7a 10 0c                   STAA LEDS
23d7 3d                 	RTS                            ; aaaaaaa
23d8                    PATRON_LEDS_desplazar_leds:            ; Logica de patron de emergencia
23d8 86 f8                      LDAA #$F8
23da b4 10 0c                   ANDA LEDS
23dd 44                         LSRA
23de 81 04                      CMPA #4
23e0 23 0b                      BLS PATRON_LEDS_reiniciar_patron  ; De nuevo se enciende el LED pb7
23e2 c6 07                      LDAB #$07            ; Guardanto en Leds el nuevo led encendido
23e4 f4 10 0c                   ANDB LEDS
23e7 18 06                      ABA
23e9 7a 10 0c                   STAA LEDS
23ec 3d                         RTS
23ed                    PATRON_LEDS_reiniciar_patron:
23ed 1c 10 0c 80                BSET LEDS,$80
23f1 1d 10 0c 08                BCLR LEDS,$08
23f5 3d                         RTS
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;-------------------------------------------------------------------------------
                        ;-------------------------------INTERRUPCIONES----------------------------------
                        ;-------------------------------------------------------------------------------
                        ;*******************************************************************************
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                                INTERRUPCION RTI_ISR
                        ;*******************************************************************************
                        ;Descripcion: Esta interrupcion se encarga de decrementar la variable CONT_REB en 1
                        ; cada 1 ms aproximadamente, si CONT_REB es cero la subrutina no hace nada.
                        
23f6                    RTI_ISR:        ; Teclado
23f6 4c 37 80                           BSET CRGFLG,#$80
23f9 f7 10 03                           TST CONT_REB      ; Si contador de rebotes es 0, no hace nada
23fc 27 03                              BEQ FIN_RTI_ISR_cont_reb
23fe 73 10 03                           DEC CONT_REB      ; decrementando contador de rebotes
2401                    FIN_RTI_ISR_cont_reb:                  ; Timer cuenta (modo run)
2401 0b                                 RTI
                        
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                                INTERRUPCION PHO_ISR
                        ;*******************************************************************************
                        ;Descripcion: Esta interrupcion se divide en 4 subrunitas:
                        ; PTH0: Borra CUENTA
                        ; PTH1: Borra ACUMUL
                        ; PTH2: Decrementa el brillo de los display de 7 segmentos
                        ; PTH3: Incrementa el brillo de los display de 7 segmentos
2402                    PHO_ISR:
2402 1e 02 67 01 0f                     BRSET PIFH,$01,PTHO
2407 1e 02 67 02 12                     BRSET PIFH,$02,PTH1
240c 1e 02 67 04 15                     BRSET PIFH,$04,PTH2
2411 1e 02 67 08 15                     BRSET PIFH,$08,PTH3
2416                    PTHO:
2416 79 10 07                   CLR CUENTA
2419 1c 02 67 01                BSET PIFH,$01     ; Desactivando interrupcion
241d 0b                         RTI
                                
                                
241e                    PTH1:
241e 79 10 08                   CLR ACUMUL
2421 1c 02 67 02                BSET PIFH,$02     ; Desactivando interrupcion
2425 0b                         RTI
                                
                                
2426                    PTH2:
                        
2426 1c 02 67 04                BSET PIFH,$04     ; Desactivando interrupcion
242a 0b                         RTI
                                
                                
242b                    PTH3:
                        
242b 1c 02 67 08                BSET PIFH,$08     ; Desactivando interrupcion
242f 0b                         RTI
                                
                                
                        
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                                INTERRUPCION OC4_ISR
                        ;*******************************************************************************
                        ;Descripcion: Esta interrupcion realiza toda la logica para que funcionen los,
                        ; 4 displa de 7 segmentos y los leds a la vez. Para informacion mas detallada
                        ; ver el enunciado de la tarea
2430                    OC4_ISR:
                        
2430 ce 10 14                   LDX #DISP1
2433 86 64                      LDAA #100                 ;Verificando si el contador de tics ya
2435 b1 10 0f                   CMPA CONT_TICKS            ; llego a 125.
2438 27 05                      BEQ OC4_ISR_tic_maximo
243a 72 10 0f                   INC CONT_TICKS             ; Iincrementando contador de tics
243d 20 3a                      BRA OC4_ISR_continuar1
243f                    OC4_ISR_tic_maximo:               ; Se debe cambiar de display
243f 79 10 0f                   CLR CONT_TICKS
2442 72 10 0e                   INC CONT_DIG
2445 f6 10 0e                   LDAB CONT_DIG
2448 c1 05                      CMPB #5                   ; Si contador de digito se sale del rango se resetea
244a 26 03                      BNE Continuar
244c 79 10 0e                   clr CONT_DIG
244f                    Continuar:
244f f6 10 0e                   LDAB CONT_DIG             ; Si el digito son los leds, se encienden
2452 c1 04                      CMPB #4
2454 27 0b                      BEQ encender_led
2456 18 0d e5 00 01             MOVB B,X,PORTB                ; Mandando datos al display
245b 1c 02 68 02                BSET PTJ,$02                  ; apagando leds
245f 20 0a                      BRA continuar2
2461                    encender_led:                        ; encendiendo leds
2461 18 0c 10 0c 00 01          MOVB LEDS,PORTB
2467 1d 02 68 02                BCLR PTJ,$02                 ;encendiendo leds
246b                    continuar2:
246b 86 f7                      LDAA #$F7                 ; Calculando cual display se debe encender
246d f6 10 0e                   LDAB CONT_DIG
2470                    OC4_ISR_loop_1:
2470 27 04                      BEQ OC4_ISR_fin_loop1
2472 44                         LSRA                      ; Se desplaza el 0 para ver cual display se enciende
2473 53                         DECB
2474 20 fa                      BRA OC4_ISR_loop_1
2476                    OC4_ISR_fin_loop1:
2476 7a 02 58                   STAA PTP                  ; Guardando resultado obtenido
2479                    OC4_ISR_continuar1:
2479 86 64                      LDAA #100                 ; Calculando cuando apagar el display
247b b0 10 0d                   SUBA BRILLO
247e 7a 10 10                   STAA DT
2481 b1 10 0f                   CMPA CONT_TICKS
2484 26 09                      BNE OC4_ISR_continuar2
2486 18 0b ff 02 58             MOVB #$FF,PTP             ; Se apaga el display
248b 1c 02 68 02                BSET PTJ,$02              ; disable leds
248f                    OC4_ISR_continuar2:
248f 1f 10 06 10 04             BRCLR BANDERAS,$10,OC4_ISR_continuar23    ; Apagando dos display en modo config
2494 1c 02 58 03                BSET PTP,$03
2498                    OC4_ISR_continuar23:
2498 fc 10 18                   LDD CONT_7SEG                 ; Calculando si ya pasaron 100ms
249b 8c 13 88                   CPD #5000
249e 27 08                      BEQ OC4_ISR_llamar
24a0 c3 00 01                   ADDD #1                       ; sumando 1 a CONT_7SEG
24a3 7c 10 18                   STD CONT_7SEG                 ; Guaradndolo
24a6 20 09                      BRA OC4_ISR_continuar3
24a8                    OC4_ISR_llamar:
24a8 18 03 00 00 10 18          MOVW #0,CONT_7SEG
24ae 16 22 b5                   JSR BCD_7SEG
24b1                    OC4_ISR_continuar3:                    ; Decrementando contador de delay si no es 0
24b1 f7 10 1a                   TST CONT_DELAY
24b4 27 03                      BEQ OC4_ISR_retornar
24b6 73 10 1a                   DEC CONT_DELAY
24b9                    OC4_ISR_retornar:
24b9 dc 44                      LDD TCNT                       ; Guardando en TC4 la siguiente interrupcion
24bb c3 00 3c                   ADDD #60
24be 5c 58                      STD TC4
24c0 0b                         RTI
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---
                        
                        
                        
                        
                        
                        
                        ;*******************************************************************************
                        ;                                INTERRUPCION ATD_ISR
                        ;*******************************************************************************
                        ;Descripcion: Esta subrutina se encarga de leer 6 valores guardados en los reg
                        ; del convertidor analogico a digital en el cual esta conectado el potenciometro
                        ; y hacer un promedio de los mismos que es guardado en la variable POT. Por
                        ; ultimo se calcula el valor de 0 a 100 (en intervalos de 5 en 5) del brillo
                        ; a ser mostrado en los display, este brillo es guardado en la variable BRILLO.
                        
24c1                    ATD_ISR:
24c1 dc 90                      LDD ADR00H      ; Haciendo un promedio de los valores del CAD que esta
24c3 d3 92                      ADDD ADR01H     ; leyendo el potenciometro
24c5 d3 94                      ADDD ADR02H
24c7 d3 96                      ADDD ADR03H
24c9 d3 98                      ADDD ADR04H
24cb d3 9a                      ADDD ADR05H
                                
24cd ce 00 06                   LDX #6          ; Calculando promedio entre los 6 datos
24d0 18 10                      IDIV
24d2 b7 54                      TFR x,d         ; Pasando resultado a D
                                
24d4 c9 00                      ADCB #0         ; Redondeando
24d6 89 00                      ADCA #0
                                
24d8 7c 10 27                   STD POT
                                
24db 86 14                      LDAA #20        ; Calculando el valor de brillo
24dd 12                         MUL             ; 20 * POT
                                
24de ce 00 ff                   LDX #255
24e1 18 10                      IDIV            ; (20 * POT) / 255
24e3 b7 54                      TFR x,d         ; Pasando resultado a D
                                
24e5 86 05                      LDAA #5         ; Calculando resultado de brillo en escala de 0 a 100
24e7 12                         MUL             ;( (20 * POT) / 255 ) * 5
24e8 7b 10 0d                   STAB BRILLO
                        
                        
24eb 18 0b 87 00 85             MOVB #%10000111,ATD0CTL5
24f0 0b                         RTI
                        
                        ;---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---

Executed: Mon Nov 25 21:40:49 2019
Total cycles: 1562, Total bytes: 1370
Total errors: 0, Total warnings: 0
